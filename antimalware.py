#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
GuardCore Anti-Malware Modülü
-----------------------------
Bu modül, zararlı yazılımları tespit etme ve engelleme işlevselliği sağlar.
Dosya tabanlı tarama, davranış analizi ve heuristic algoritmalar kullanır.

Yazarlar: GuardCore Dev Team
Lisans: MIT
Versiyon: 0.1.0
"""

import os
import time
import hashlib
import threading
import logging
from typing import Dict, List, Any, Set, Optional
from pathlib import Path

from guardcore.modules import ProtectionModule
from guardcore.modules.common.event import Event, EventType, EventSeverity
from guardcore.modules.common.threat import (
    Threat, ThreatCategory, ThreatSeverity, ThreatStatus,
    create_threat_from_detection
)


class AntimalwareModule(ProtectionModule):
    """
    Anti-malware koruma modülü.
    Zararlı yazılımları tespit etme, engelleme ve temizleme işlevleri sağlar.
    """
    
    def __init__(self, engine, settings):
        """
        AntimalwareModule sınıfını başlatır.
        
        Args:
            engine: Ana motor referansı
            settings: Yapılandırma ayarları
        """
        super().__init__(engine, settings)
        
        # Modüle özel değişkenler
        self.signature_db = {}
        self.signature_version = "0.0.0"
        self.signature_last_update = 0
        
        # Tarama durumu
        self.scan_status = {
            "is_scanning": False,
            "current_scan_id": None,
            "scan_start_time": 0,
            "scanned_files": 0,
            "detected_threats": 0
        }
        
        # Bilinen zararlı hash'ler (örnek)
        self.malware_hashes = set()
        
        # Tarama istatistikleri
        self.scan_stats = {
            "total_scans": 0,
            "total_files_scanned": 0,
            "total_detections": 0,
            "last_scan_time": 0
        }
        
        # İzlenen dosya uzantıları
        self.monitored_extensions = {
            '.exe', '.dll', '.bat', '.cmd', '.ps1', '.vbs', '.js',
            '.jar', '.py', '.php', '.sh', '.pl', '.com'
        }
        
        # İzlenen dosya yolları
        self.monitored_paths = []
        
        # İzleme iş parçacığı
        self.file_monitor_thread = None
        
        # Tarama durdurma bayrağı
        self.stop_scan = False
    
    def _initialize(self) -> bool:
        """
        Anti-malware modülünü başlatır.
        
        Returns:
            bool: Başlatma başarılı mı?
        """
        self.logger.info("Anti-malware modülü başlatılıyor...")
        
        try:
            # İzlenen yolları yükle
            self._load_monitored_paths()
            
            # İmza veritabanını yükle
            success = self._load_signatures()
            if not success:
                self.logger.warning("İmza veritabanı yüklenemedi, devam ediliyor...")
            
            # Dosya izleme iş parçacığını başlat
            if self.config.get("realtime_protection", True):
                self._start_file_monitoring()
            
            # Zamanlanmış görevleri ayarla
            self._setup_scheduled_tasks()
            
            self.logger.info("Anti-malware modülü başarıyla başlatıldı")
            return True
            
        except Exception as e:
            self.logger.error(f"Anti-malware modülü başlatılırken hata: {e}", exc_info=True)
            return False
    
    def _shutdown(self) -> bool:
        """
        Anti-malware modülünü durdurur.
        
        Returns:
            bool: Durdurma başarılı mı?
        """
        self.logger.info("Anti-malware modülü durduruluyor...")
        
        try:
            # Mevcut taramayı durdur
            self.stop_scan = True
            
            # İş parçacıklarını durdur (temel sınıf hallediyor)
            
            self.logger.info("Anti-malware modülü durduruldu")
            return True
            
        except Exception as e:
            self.logger.error(f"Anti-malware modülü durdurulurken hata: {e}", exc_info=True)
            return False
    
    def _process_event(self, event: Event) -> bool:
        """
        Bir olayı işler.
        
        Args:
            event (Event): İşlenecek olay
            
        Returns:
            bool: İşleme başarılı mı?
        """
        # Olay tipine göre işle
        if event.type == EventType.FILE_CREATED or event.type == EventType.FILE_MODIFIED:
            # Dosya olaylarını işle
            return self._handle_file_event(event)
            
        elif event.type == EventType.PROCESS_STARTED:
            # İşlem başlatma olaylarını işle
            return self._handle_process_event(event)
            
        elif event.type == EventType.SCAN_START:
            # Tarama başlatma olayını işle
            scan_type = event.details.get("scan_type", "quick")
            scan_id = event.details.get("scan_id", None)
            return self._handle_scan_request(scan_type, scan_id)
        
        # Diğer olaylar için başarılı kabul et
        return True
    
    def _can_handle_event(self, event: Event) -> bool:
        """
        Bu modülün belirli bir olayı işleyebilip işleyemeyeceğini kontrol eder.
        
        Args:
            event (Event): Kontrol edilecek olay
            
        Returns:
            bool: Bu modül olayı işleyebilir mi?
        """
        # İşlenebilecek olay tipleri
        handled_events = [
            EventType.FILE_CREATED,
            EventType.FILE_MODIFIED,
            EventType.PROCESS_STARTED,
            EventType.SCAN_START
        ]
        
        return event.type in handled_events
    
    def _respond_to_threat(self, threat: Threat) -> bool:
        """
        Bir tehdide yanıt verir.
        
        Args:
            threat (Threat): Yanıtlanacak tehdit
            
        Returns:
            bool: Yanıt başarılı mı?
        """
        self.logger.info(f"Tehdide yanıt veriliyor: {threat.id} ({threat.name})")
        
        # Tehdit türüne göre işlem yap
        if threat.category in [ThreatCategory.MALWARE, ThreatCategory.VIRUS, 
                              ThreatCategory.TROJAN, ThreatCategory.RANSOMWARE]:
            # Zararlı yazılım tehdidi
            return self._handle_malware_threat(threat)
            
        elif threat.category == ThreatCategory.SUSPICIOUS_PROCESS:
            # Şüpheli işlem tehdidi
            return self._handle_suspicious_process(threat)
        
        # Desteklenmeyen tehdit türü
        self.logger.warning(f"Desteklenmeyen tehdit türü: {threat.category}")
        return False
    
    def _can_handle_threat(self, threat: Threat) -> bool:
        """
        Bu modülün belirli bir tehdidi işleyebilip işleyemeyeceğini kontrol eder.
        
        Args:
            threat (Threat): Kontrol edilecek tehdit
            
        Returns:
            bool: Bu modül tehdidi işleyebilir mi?
        """
        # İşlenebilecek tehdit kategorileri
        handled_categories = [
            ThreatCategory.MALWARE,
            ThreatCategory.VIRUS,
            ThreatCategory.TROJAN,
            ThreatCategory.RANSOMWARE,
            ThreatCategory.SPYWARE,
            ThreatCategory.ADWARE,
            ThreatCategory.WORM,
            ThreatCategory.ROOTKIT,
            ThreatCategory.KEYLOGGER,
            ThreatCategory.SUSPICIOUS_PROCESS
        ]
        
        return threat.category in handled_categories
    
    def _health_check(self) -> bool:
        """
        Modülün sağlık durumunu kontrol eder.
        
        Returns:
            bool: Modül sağlıklı çalışıyor mu?
        """
        # İmza veritabanı yüklü mü?
        if not self.signature_db:
            self.logger.warning("İmza veritabanı yüklü değil")
            return False
        
        # İmza veritabanı çok eski mi?
        if time.time() - self.signature_last_update > 7 * 24 * 3600:  # 7 gün
            self.logger.warning("İmza veritabanı güncel değil")
            # Sağlıksız sayma, sadece uyarı ver
        
        # Dosya izleme iş parçacığı çalışıyor mu?
        if self.config.get("realtime_protection", True) and (
            not self.file_monitor_thread or not self.file_monitor_thread.is_alive()
        ):
            self.logger.warning("Dosya izleme iş parçacığı çalışmıyor")
            return False
        
        return True
    
    def _get_status(self) -> Dict[str, Any]:
        """
        Modülün durum bilgisini döndürür.
        
        Returns:
            Dict[str, Any]: Durum bilgilerini içeren sözlük
        """
        return {
            "realtime_protection": self.config.get("realtime_protection", True),
            "signature_version": self.signature_version,
            "signature_last_update": self.signature_last_update,
            "is_scanning": self.scan_status["is_scanning"],
            "stats": self.scan_stats,
            "monitored_paths_count": len(self.monitored_paths)
        }
    
    def run_quick_scan(self) -> Dict[str, Any]:
        """
        Hızlı tarama gerçekleştirir.
        
        Returns:
            Dict[str, Any]: Tarama sonuçları
        """
        self.logger.info("Hızlı tarama başlatılıyor...")
        
        # Tarama kimliği oluştur
        scan_id = f"quick_scan_{int(time.time())}"
        
        # Tarama durumunu güncelle
        self.scan_status = {
            "is_scanning": True,
            "current_scan_id": scan_id,
            "scan_start_time": time.time(),
            "scanned_files": 0,
            "detected_threats": 0
        }
        
        self.stop_scan = False
        
        try:
            # Kritik sistem yollarını tarama için hazırla
            paths_to_scan = self._get_quick_scan_paths()
            
            # Tarama gerçekleştir
            threats = []
            for path in paths_to_scan:
                if self.stop_scan:
                    self.logger.info("Tarama durduruldu")
                    break
                
                path_threats = self._scan_path(path, quick=True)
                threats.extend(path_threats)
            
            # Tarama istatistiklerini güncelle
            self.scan_stats["total_scans"] += 1
            self.scan_stats["total_files_scanned"] += self.scan_status["scanned_files"]
            self.scan_stats["total_detections"] += len(threats)
            self.scan_stats["last_scan_time"] = time.time()
            
            # Tarama sonuçları
            scan_results = {
                "scan_id": scan_id,
                "scan_type": "quick",
                "scanned_files": self.scan_status["scanned_files"],
                "threats": [threat.to_dict() for threat in threats],
                "duration": time.time() - self.scan_status["scan_start_time"],
                "success": True
            }
            
            self.logger.info(f"Hızlı tarama tamamlandı: {self.scan_status['scanned_files']} dosya, {len(threats)} tehdit")
            
            # Tarama durumunu sıfırla
            self.scan_status["is_scanning"] = False
            
            return scan_results
            
        except Exception as e:
            self.logger.error(f"Hızlı tarama sırasında hata: {e}", exc_info=True)
            
            # Hata sonuçları
            scan_results = {
                "scan_id": scan_id,
                "scan_type": "quick",
                "scanned_files": self.scan_status["scanned_files"],
                "threats": [],
                "duration": time.time() - self.scan_status["scan_start_time"],
                "success": False,
                "error": str(e)
            }
            
            # Tarama durumunu sıfırla
            self.scan_status["is_scanning"] = False
            
            return scan_results
    
    def run_full_scan(self) -> Dict[str, Any]:
        """
        Tam tarama gerçekleştirir.
        
        Returns:
            Dict[str, Any]: Tarama sonuçları
        """
        self.logger.info("Tam tarama başlatılıyor...")
        
        # Tarama kimliği oluştur
        scan_id = f"full_scan_{int(time.time())}"
        
        # Tarama durumunu güncelle
        self.scan_status = {
            "is_scanning": True,
            "current_scan_id": scan_id,
            "scan_start_time": time.time(),
            "scanned_files": 0,
            "detected_threats": 0
        }
        
        self.stop_scan = False
        
        try:
            # Tüm diskleri tarama için hazırla
            paths_to_scan = self._get_full_scan_paths()
            
            # Tarama gerçekleştir
            threats = []
            for path in paths_to_scan:
                if self.stop_scan:
                    self.logger.info("Tarama durduruldu")
                    break
                
                path_threats = self._scan_path(path, quick=False)
                threats.extend(path_threats)
            
            # Tarama istatistiklerini güncelle
            self.scan_stats["total_scans"] += 1
            self.scan_stats["total_files_scanned"] += self.scan_status["scanned_files"]
            self.scan_stats["total_detections"] += len(threats)
            self.scan_stats["last_scan_time"] = time.time()
            
            # Tarama sonuçları
            scan_results = {
                "scan_id": scan_id,
                "scan_type": "full",
                "scanned_files": self.scan_status["scanned_files"],
                "threats": [threat.to_dict() for threat in threats],
                "duration": time.time() - self.scan_status["scan_start_time"],
                "success": True
            }
            
            self.logger.info(f"Tam tarama tamamlandı: {self.scan_status['scanned_files']} dosya, {len(threats)} tehdit")
            
            # Tarama durumunu sıfırla
            self.scan_status["is_scanning"] = False
            
            return scan_results
            
        except Exception as e:
            self.logger.error(f"Tam tarama sırasında hata: {e}", exc_info=True)
            
            # Hata sonuçları
            scan_results = {
                "scan_id": scan_id,
                "scan_type": "full",
                "scanned_files": self.scan_status["scanned_files"],
                "threats": [],
                "duration": time.time() - self.scan_status["scan_start_time"],
                "success": False,
                "error": str(e)
            }
            
            # Tarama durumunu sıfırla
            self.scan_status["is_scanning"] = False
            
            return scan_results
    
    def scan_file(self, file_path: str) -> Optional[Threat]:
        """
        Tek bir dosyayı tarar.
        
        Args:
            file_path (str): Taranacak dosya yolu
            
        Returns:
            Optional[Threat]: Tespit edilen tehdit veya None
        """
        self.logger.debug(f"Dosya taranıyor: {file_path}")
        
        try:
            # Dosya var mı kontrol et
            if not os.path.isfile(file_path):
                self.logger.warning(f"Dosya bulunamadı: {file_path}")
                return None
            
            # Dosya uzantısını kontrol et
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext not in self.monitored_extensions:
                self.logger.debug(f"İzlenmeyen dosya uzantısı: {file_ext}")
                return None
            
            # Dosya boyutunu kontrol et
            file_size = os.path.getsize(file_path)
            max_size = self.config.get("max_file_size", 100) * 1024 * 1024  # MB -> Byte
            if file_size > max_size:
                self.logger.warning(f"Dosya çok büyük: {file_path} ({file_size} bytes)")
                return None
            
            # Dosya hash'ini hesapla
            file_hash = self._calculate_file_hash(file_path)
            if not file_hash:
                return None
            
            # Hash'i imza veritabanında kontrol et
            if file_hash in self.malware_hashes:
                # Zararlı yazılım tespit edildi
                threat = create_threat_from_detection(
                    name="Bilinen Zararlı Yazılım",
                    category=ThreatCategory.MALWARE,
                    severity=ThreatSeverity.HIGH,
                    source=self.module_name,
                    details={
                        "file_path": file_path,
                        "file_hash": file_hash,
                        "detection_type": "signature",
                        "description": "Dosya, bilinen zararlı yazılım imzası ile eşleşiyor.",
                        "recommended_actions": [
                            "Dosyayı karantinaya al",
                            "Dosyayı sil"
                        ]
                    }
                )
                
                # Dosyayı tehdit listesine ekle
                threat.add_affected_file(file_path)
                
                self.logger.warning(f"Zararlı yazılım tespit edildi: {file_path} ({file_hash})")
                return threat
            
            # Heuristic analiz (örnek)
            suspicious_patterns = self._check_suspicious_patterns(file_path)
            if suspicious_patterns:
                # Şüpheli dosya tespit edildi
                threat = create_threat_from_detection(
                    name="Şüpheli Dosya",
                    category=ThreatCategory.SUSPICIOUS_PROCESS,
                    severity=ThreatSeverity.MEDIUM,
                    source=self.module_name,
                    details={
                        "file_path": file_path,
                        "file_hash": file_hash,
                        "detection_type": "heuristic",
                        "suspicious_patterns": suspicious_patterns,
                        "description": "Dosya, şüpheli davranış kalıpları içeriyor.",
                        "recommended_actions": [
                            "Dosyayı analiz et",
                            "Dosyayı karantinaya al"
                        ]
                    }
                )
                
                # Dosyayı tehdit listesine ekle
                threat.add_affected_file(file_path)
                
                self.logger.warning(f"Şüpheli dosya tespit edildi: {file_path}")
                return threat
            
            # Tehdit tespit edilmedi
            return None
            
        except Exception as e:
            self.logger.error(f"Dosya taranırken hata: {e}")
            return None
    
    def quarantine_file(self, file_path: str) -> bool:
        """
        Bir dosyayı karantinaya alır.
        
        Args:
            file_path (str): Karantinaya alınacak dosya yolu
            
        Returns:
            bool: İşlem başarılı mı?
        """
        self.logger.info(f"Dosya karantinaya alınıyor: {file_path}")
        
        try:
            # Dosya var mı kontrol et
            if not os.path.isfile(file_path):
                self.logger.warning(f"Karantinaya alınacak dosya bulunamadı: {file_path}")
                return False
            
            # Karantina klasörünü oluştur
            quarantine_dir = os.path.join(
                self.config.get("quarantine_path", "/var/guardcore/quarantine")
            )
            os.makedirs(quarantine_dir, exist_ok=True)
            
            # Karantina dosya yolunu oluştur
            file_name = os.path.basename(file_path)
            quarantine_path = os.path.join(
                quarantine_dir, 
                f"{file_name}_{int(time.time())}.qrn"
            )
            
            # Dosyayı şifrele ve karantinaya al (basit örnek)
            with open(file_path, 'rb') as src_file:
                file_content = src_file.read()
                
                # Basit XOR şifreleme (gerçek uygulamada daha güçlü şifreleme kullanılmalı)
                encrypted_content = bytes([b ^ 0x42 for b in file_content])
                
                with open(quarantine_path, 'wb') as dst_file:
                    dst_file.write(encrypted_content)
            
            # Orijinal dosyayı sil
            os.remove(file_path)
            
            self.logger.info(f"Dosya başarıyla karantinaya alındı: {file_path} -> {quarantine_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Dosya karantinaya alınırken hata: {e}")
            return False
    
    def _load_monitored_paths(self) -> None:
        """
        İzlenen yolları yapılandırmadan yükler.
        """
        # Yapılandırmadan yolları al
        paths = self.config.get("monitored_paths", [])
        
        # Varsayılan yolları ekle
        if not paths:
            if os.name == 'nt':  # Windows
                paths = [
                    os.path.join(os.environ['SYSTEMDRIVE'], '\\'),
                    os.path.join(os.environ['SYSTEMROOT']),
                    os.path.join(os.environ['PROGRAMFILES']),
                    os.path.join(os.environ['APPDATA'])
                ]
            else:  # Linux/macOS
                paths = [
                    '/bin',
                    '/usr/bin',
                    '/sbin',
                    '/usr/sbin',
                    '/home',
                    '/tmp'
                ]
        
        # Yolları kontrol et ve ekle
        for path in paths:
            if os.path.exists(path):
                self.monitored_paths.append(path)
            else:
                self.logger.warning(f"İzlenen yol bulunamadı: {path}")
        
        self.logger.info(f"İzlenen yollar yüklendi: {len(self.monitored_paths)} yol")
    
    def _load_signatures(self) -> bool:
        """
        İmza veritabanını yükler.
        
        Returns:
            bool: Yükleme başarılı mı?
        """
        self.logger.info("İmza veritabanı yükleniyor...")
        
        try:
            # Yapılandırmadan imza veritabanı yolunu al
            signature_path = self.config.get("signature_path", "/var/guardcore/signatures")
            
            # Burada gerçek bir imza veritabanı yüklenecek
            # Şimdilik örnek veri ile doldur
            
            # Örnek malware hash'leri
            self.malware_hashes = {
                "44d88612fea8a8f36de82e1278abb02f",
                "5267b02c4e7675adf36d93ae4a4c246b",
                "b59c67bf196a4758191e42f76670ceba",
                "a5b8edb45b9daed0a56b0242a21243ca"
            }
            
            # İmza veritabanı bilgilerini güncelle
            self.signature_version = "1.0.0"
            self.signature_last_update = time.time()
            
            self.logger.info(f"İmza veritabanı yüklendi: {len(self.malware_hashes)} imza")
            return True
            
        except Exception as e:
            self.logger.error(f"İmza veritabanı yüklenirken hata: {e}")
            return False
    
    def _start_file_monitoring(self) -> None:
        """
        Gerçek zamanlı dosya izleme iş parçacığını başlatır.
        """
        self.logger.info("Gerçek zamanlı koruma başlatılıyor...")
        
        # Dosya izleme iş parçacığını oluştur
        self.file_monitor_thread = self._create_thread(
            target=self._file_monitor_loop,
            name="FileMonitor",
            daemon=True
        )
        
        self.logger.info("Gerçek zamanlı koruma başlatıldı")
    
    def _file_monitor_loop(self) -> None:
        """
        Dosya izleme döngüsü.
        """
        self.logger.debug("Dosya izleme iş parçacığı başlatıldı")
        
        while self.is_running:
            try:
                # Kalp atışını güncelle
                self._heartbeat()
                
                # Burada gerçek bir dosya izleme sistemi uygulanacak
                # Örneğin: inotify, FSEvents, Windows API vb.
                
                # Şimdilik sadece bir simülasyon
                time.sleep(10)
                
            except Exception as e:
                self.logger.error(f"Dosya izleme döngüsünde hata: {e}")
                time.sleep(5)  # Hata durumunda biraz bekle
    
    def _setup_scheduled_tasks(self) -> None:
        """
        Zamanlanmış görevleri ayarlar.
        """
        # İmza güncellemesi zamanlayıcısı
        if self.config.get("auto_update_signatures", True):
            self.engine.scheduler.schedule_task(
                self._update_signatures,
                interval=24 * 3600,  # 24 saat
                name="SignatureUpdate"
            )
        
        # Periyodik tarama zamanlayıcısı
        if self.config.get("scheduled_scan.enabled", True):
            # Günlük hızlı tarama
            self.engine.scheduler.schedule_task(
                self._scheduled_quick_scan,
                interval=24 * 3600,  # 24 saat
                name="DailyQuickScan"
            )
            
            # Haftalık tam tarama
            self.engine.scheduler.schedule_task(
                self._scheduled_full_scan,
                interval=7 * 24 * 3600,  # 1 hafta
                name="WeeklyFullScan"
            )
    
    def _scheduled_quick_scan(self) -> None:
        """
        Zamanlanmış hızlı tarama gerçekleştirir.
        """
        self.logger.info("Zamanlanmış hızlı tarama başlatılıyor...")
        
        # Mevcut tarama var mı kontrol et
        if self.scan_status["is_scanning"]:
            self.logger.warning("Başka bir tarama devam ediyor, zamanlanmış tarama atlanıyor")
            return
        
        # Hızlı tarama gerçekleştir
        results = self.run_quick_scan()
        
        # Tehditleri işle
        threats = [Threat.from_dict(t) for t in results.get("threats", [])]
        if threats:
            self.logger.warning(f"{len(threats)} tehdit tespit edildi, işleniyor...")
            for threat in threats:
                # Tehdidi motora gönder
                self.engine.process_event(
                    self._create_event(
                        event_type=EventType.THREAT_DETECTED,
                        details={"threat": threat.to_dict()},
                        severity=EventSeverity.WARNING
                    )
                )
    
    def _scheduled_full_scan(self) -> None:
        """
        Zamanlanmış tam tarama gerçekleştirir.
        """
        self.logger.info("Zamanlanmış tam tarama başlatılıyor...")
        
        # Mevcut tarama var mı kontrol et
        if self.scan_status["is_scanning"]:
            self.logger.warning("Başka bir tarama devam ediyor, zamanlanmış tarama atlanıyor")
            return
        
        # Tam tarama gerçekleştir
        results = self.run_full_scan()
        
        # Tehditleri işle
        threats = [Threat.from_dict(t) for t in results.get("threats", [])]
        if threats:
            self.logger.warning(f"{len(threats)} tehdit tespit edildi, işleniyor...")
            for threat in threats:
                # Tehdidi motora gönder
                self.engine.process_event(
                    self._create_event(
                        event_type=EventType.THREAT_DETECTED,
                        details={"threat": threat.to_dict()},
                        severity=EventSeverity.WARNING
                    )
                )
    
    def _update_signatures(self) -> bool:
        """
        İmza veritabanını günceller.
        
        Returns:
            bool: Güncelleme başarılı mı?
        """
        self.logger.info("İmza veritabanı güncelleniyor...")
        
        try:
            # Burada gerçek bir imza güncelleme işlemi yapılacak
            # Örneğin: Sunucudan yeni imzaları indir
            
            # Örnek güncelleme
            time.sleep(2)  # Simülasyon
            
            # İmza veritabanı bilgilerini güncelle
            self.signature_version = "1.0.1"
            self.signature_last_update = time.time()
            
            self.logger.info(f"İmza veritabanı güncellendi: v{self.signature_version}")
            return True
            
        except Exception as e:
            self.logger.error(f"İmza veritabanı güncellenirken hata: {e}")
            return False
    
    def _scan_path(self, path: str, quick: bool = True) -> List[Threat]:
        """
        Belirli bir yolu tarar.
        
        Args:
            path (str): Taranacak yol
            quick (bool): Hızlı tarama mı?
            
        Returns:
            List[Threat]: Tespit edilen tehditler
        """
        threats = []
        
        try:
            for root, dirs, files in os.walk(path):
                if self.stop_scan:
                    break
                
                # Dizin filtreleme
                if quick:
                    # Hızlı taramada bazı dizinleri atla
                    dirs[:] = [d for d in dirs if not self._should_skip_directory(os.path.join(root, d))]
                
                # Dosyaları tara
                for file in files:
                    if self.stop_scan:
                        break
                    
                    file_path = os.path.join(root, file)
                    
                    # Dosya uzantısını kontrol et
                    file_ext = os.path.splitext(file)[1].lower()
                    if file_ext not in self.monitored_extensions:
                        continue
                    
                    # Dosyayı tara
                    threat = self.scan_file(file_path)
                    if threat:
                        threats.append(threat)
                    
                    # Taranan dosya sayısını güncelle
                    self.scan_status["scanned_files"] += 1
                    
                    # Her 100 dosyada bir log
                    if self.scan_status["scanned_files"] % 100 == 0:
                        self.logger.debug(f"{self.scan_status['scanned_files']} dosya tarandı, {len(threats)} tehdit bulundu")
        
        except Exception as e:
            self.logger.error(f"Yol taranırken hata: {e}")
        
        return threats
    
    def _should_skip_directory(self, dir_path: str) -> bool:
        """
        Belirli bir dizinin taramada atlanıp atlanmayacağını kontrol eder.
        
        Args:
            dir_path (str): Kontrol edilecek dizin yolu
            
        Returns:
            bool: Dizin atlanmalı mı?
        """
        # Atlanacak dizin adları
        skip_dirs = {
            'node_modules', 'vendor', '.git', '.svn', 'venv', 'env',
            '.vscode', '.idea', '__pycache__', 'tmp', 'temp'
        }
        
        dir_name = os.path.basename(dir_path)
        
        # Dizin adına göre atla
        if dir_name in skip_dirs:
            return True
        
        # Gizli dizinleri atla
        if dir_name.startswith('.'):
            return True
        
        return False
    
    def _calculate_file_hash(self, file_path: str) -> Optional[str]:
        """
        Bir dosyanın MD5 hash'ini hesaplar.
        
        Args:
            file_path (str): Dosya yolu
            
        Returns:
            Optional[str]: Hesaplanan hash veya None
        """
        try:
            hasher = hashlib.md5()
            
            with open(file_path, 'rb') as f:
                # Büyük dosyalar için blok blok okuma
                buffer_size = 65536  # 64 KB
                data = f.read(buffer_size)
                while data:
                    hasher.update(data)
                    data = f.read(buffer_size)
            
            return hasher.hexdigest()
            
        except Exception as e:
            self.logger.error(f"Dosya hash'i hesaplanırken hata: {file_path} - {e}")
            return None
    
    def _check_suspicious_patterns(self, file_path: str) -> List[str]:
        """
        Bir dosyada şüpheli kalıpları kontrol eder.
        
        Args:
            file_path (str): Dosya yolu
            
        Returns:
            List[str]: Tespit edilen şüpheli kalıplar
        """
        suspicious_patterns = []
        
        try:
            # Dosya uzantısını al
            file_ext = os.path.splitext(file_path)[1].lower()
            
            # Çalıştırılabilir dosyalar için
            if file_ext in ['.exe', '.dll', '.sys']:
                # Burada gerçek davranış analizi yapılacak
                # Örneğin: PE header analizi, içerik analizi vb.
                pass
                
            # Script dosyaları için
            elif file_ext in ['.bat', '.ps1', '.vbs', '.js', '.py']:
                # İçerik analizi
                with open(file_path, 'r', errors='ignore') as f:
                    content = f.read()
                    
                    # Şüpheli kalıpları kontrol et (basit örnek)
                    if "powershell -encodedcommand" in content.lower():
                        suspicious_patterns.append("PowerShell encoded command")
                    
                    if "net user administrator" in content.lower():
                        suspicious_patterns.append("Administrator password change attempt")
                    
                    if "process::create" in content.lower() and "hidden" in content.lower():
                        suspicious_patterns.append("Hidden process creation")
            
        except Exception as e:
            self.logger.error(f"Şüpheli kalıplar kontrol edilirken hata: {file_path} - {e}")
        
        return suspicious_patterns
    
    def _handle_file_event(self, event: Event) -> bool:
        """
        Dosya olayını işler.
        
        Args:
            event (Event): İşlenecek olay
            
        Returns:
            bool: İşleme başarılı mı?
        """
        # Dosya yolunu al
        file_path = event.details.get("file_path")
        if not file_path:
            self.logger.warning("Dosya olayında dosya yolu bulunamadı")
            return False
        
        # Dosyayı tara
        threat = self.scan_file(file_path)
        
        if threat:
            # Tehdit tespit edildi
            self.logger.warning(f"Tehdit tespit edildi: {file_path}")
            
            # Tehdit sayısını güncelle
            self.stats["threats_detected"] += 1
            self.stats["last_detection_time"] = time.time()
            
            # Tehdidi motora gönder
            self.engine.process_event(
                self._create_event(
                    event_type=EventType.THREAT_DETECTED,
                    details={"threat": threat.to_dict()},
                    severity=EventSeverity.WARNING
                )
            )
            
            # Otomatik eylem gerekiyor mu?
            if self.config.get("auto_action", "quarantine") == "quarantine":
                # Dosyayı karantinaya al
                if self.quarantine_file(file_path):
                    # Tehdit durumunu güncelle
                    threat.update_status(ThreatStatus.QUARANTINED)
                    
                    # Tehdidi motora gönder
                    self.engine.process_event(
                        self._create_event(
                            event_type=EventType.THREAT_QUARANTINED,
                            details={"threat": threat.to_dict()},
                            severity=EventSeverity.INFO
                        )
                    )
                    
                    # Engellenen tehdit sayısını güncelle
                    self.stats["threats_blocked"] += 1
            
            return True
        
        return True
    
    def _handle_process_event(self, event: Event) -> bool:
        """
        İşlem başlatma olayını işler.
        
        Args:
            event (Event): İşlenecek olay
            
        Returns:
            bool: İşleme başarılı mı?
        """
        # İşlem bilgilerini al
        process_path = event.details.get("process_path")
        process_id = event.details.get("process_id")
        
        if not process_path or not process_id:
            self.logger.warning("İşlem olayında gerekli bilgiler bulunamadı")
            return False
        
        # İşlem dosyasını tara
        threat = self.scan_file(process_path)
        
        if threat:
            # Tehdit tespit edildi
            self.logger.warning(f"Tehditli işlem tespit edildi: {process_path} (PID: {process_id})")
            
            # İşlem ID'sini ekle
            threat.add_affected_process(process_id)
            
            # Tehdidi motora gönder
            self.engine.process_event(
                self._create_event(
                    event_type=EventType.THREAT_DETECTED,
                    details={"threat": threat.to_dict()},
                    severity=EventSeverity.WARNING
                )
            )
            
            # Otomatik eylem gerekiyor mu?
            if self.config.get("auto_action", "quarantine") == "quarantine":
                # İşlemi sonlandır (gerçek uygulamada)
                # self._terminate_process(process_id)
                
                # Dosyayı karantinaya al
                if self.quarantine_file(process_path):
                    # Tehdit durumunu güncelle
                    threat.update_status(ThreatStatus.QUARANTINED)
                    
                    # Tehdidi motora gönder
                    self.engine.process_event(
                        self._create_event(
                            event_type=EventType.THREAT_QUARANTINED,
                            details={"threat": threat.to_dict()},
                            severity=EventSeverity.INFO
                        )
                    )
                    
                    # Engellenen tehdit sayısını güncelle
                    self.stats["threats_blocked"] += 1
            
            return True
        
        return True
    
    def _handle_scan_request(self, scan_type: str, scan_id: Optional[str] = None) -> bool:
        """
        Tarama isteğini işler.
        
        Args:
            scan_type (str): Tarama tipi
            scan_id (Optional[str]): Tarama ID'si
            
        Returns:
            bool: İşleme başarılı mı?
        """
        # Mevcut tarama var mı kontrol et
        if self.scan_status["is_scanning"]:
            self.logger.warning("Başka bir tarama devam ediyor, istek atlanıyor")
            return False
        
        # Tarama tipine göre işlem yap
        if scan_type == "quick":
            # Hızlı tarama için iş parçacığı başlat
            self._create_thread(
                target=self.run_quick_scan,
                name="QuickScan"
            )
            return True
            
        elif scan_type == "full":
            # Tam tarama için iş parçacığı başlat
            self._create_thread(
                target=self.run_full_scan,
                name="FullScan"
            )
            return True
            
        else:
            self.logger.warning(f"Desteklenmeyen tarama tipi: {scan_type}")
            return False
    
    def _handle_malware_threat(self, threat: Threat) -> bool:
        """
        Zararlı yazılım tehdidini işler.
        
        Args:
            threat (Threat): İşlenecek tehdit
            
        Returns:
            bool: İşleme başarılı mı?
        """
        self.logger.info(f"Zararlı yazılım tehdidi işleniyor: {threat.id} ({threat.name})")
        
        try:
            # Etkilenen dosyaları karantinaya al
            for file_path in threat.affected_files:
                if os.path.exists(file_path):
                    self.quarantine_file(file_path)
            
            # Etkilenen işlemleri sonlandır (gerçek uygulamada)
            # for process_id in threat.affected_processes:
            #     self._terminate_process(process_id)
            
            # Tehdit durumunu güncelle
            threat.update_status(ThreatStatus.QUARANTINED)
            
            # Tehdidi motora gönder
            self.engine.process_event(
                self._create_event(
                    event_type=EventType.THREAT_QUARANTINED,
                    details={"threat": threat.to_dict()},
                    severity=EventSeverity.INFO
                )
            )
            
            return True
            
        except Exception as e:
            self.logger.error(f"Zararlı yazılım tehdidi işlenirken hata: {e}")
            return False
    
    def _handle_suspicious_process(self, threat: Threat) -> bool:
        """
        Şüpheli işlem tehdidini işler.
        
        Args:
            threat (Threat): İşlenecek tehdit
            
        Returns:
            bool: İşleme başarılı mı?
        """
        self.logger.info(f"Şüpheli işlem tehdidi işleniyor: {threat.id} ({threat.name})")
        
        try:
            # Şüpheli işlemlere yanıt yapılandırmasını kontrol et
            action = self.config.get("suspicious_process_action", "monitor")
            
            if action == "quarantine":
                # Etkilenen dosyaları karantinaya al
                for file_path in threat.affected_files:
                    if os.path.exists(file_path):
                        self.quarantine_file(file_path)
                
                # Tehdit durumunu güncelle
                threat.update_status(ThreatStatus.QUARANTINED)
                
                # Tehdidi motora gönder
                self.engine.process_event(
                    self._create_event(
                        event_type=EventType.THREAT_QUARANTINED,
                        details={"threat": threat.to_dict()},
                        severity=EventSeverity.INFO
                    )
                )
                
            elif action == "monitor":
                # Sadece izle ve rapor et
                threat.update_status(ThreatStatus.DETECTED)
                
                # Tehdidi motora gönder
                self.engine.process_event(
                    self._create_event(
                        event_type=EventType.THREAT_DETECTED,
                        details={"threat": threat.to_dict()},
                        severity=EventSeverity.WARNING
                    )
                )
            
            return True
            
        except Exception as e:
            self.logger.error(f"Şüpheli işlem tehdidi işlenirken hata: {e}")
            return False
    
    def _get_quick_scan_paths(self) -> List[str]:
        """
        Hızlı tarama için taranacak yolları döndürür.
        
        Returns:
            List[str]: Taranacak yollar
        """
        # Yapılandırmadan yolları al
        paths = self.config.get("quick_scan_paths", [])
        
        # Varsayılan yolları ekle
        if not paths:
            if os.name == 'nt':  # Windows
                paths = [
                    os.path.join(os.environ['SYSTEMROOT'], 'System32'),
                    os.path.join(os.environ['SYSTEMROOT'], 'SysWOW64'),
                    os.path.join(os.environ['PROGRAMFILES']),
                    os.path.join(os.environ['USERPROFILE'], 'Downloads'),
                    os.path.join(os.environ['USERPROFILE'], 'Desktop')
                ]
            else:  # Linux/macOS
                paths = [
                    '/bin',
                    '/usr/bin',
                    '/sbin',
                    '/usr/sbin',
                    '/tmp',
                    os.path.expanduser('~/Downloads'),
                    os.path.expanduser('~/Desktop')
                ]
        
        # Var olan yolları filtrele
        return [path for path in paths if os.path.exists(path)]
    
    def _get_full_scan_paths(self) -> List[str]:
        """
        Tam tarama için taranacak yolları döndürür.
        
        Returns:
            List[str]: Taranacak yollar
        """
        # Yapılandırmadan yolları al
        paths = self.config.get("full_scan_paths", [])
        
        # Varsayılan yolları ekle
        if not paths:
            if os.name == 'nt':  # Windows
                # Tüm sürücüleri bul
                import win32api
                drives = win32api.GetLogicalDriveStrings()
                paths = drives.split('\000')[:-1]  # Son boş elemanı çıkar
            else:  # Linux/macOS
                paths = ['/']
        
        # Var olan yolları filtrele
        return [path for path in paths if os.path.exists(path)]